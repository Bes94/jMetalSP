//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
package org.uma.jmetalsp.application.biobjectivetsp.streamingDataSource;

import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.function.VoidFunction;
import org.apache.spark.api.java.function.VoidFunction2;
import org.apache.spark.streaming.Time;
import org.apache.spark.streaming.api.java.JavaDStream;
import org.apache.spark.streaming.api.java.JavaStreamingContext;
import org.apache.spark.streaming.twitter.TwitterUtils;
import org.uma.jmetal.solution.PermutationSolution;
import org.uma.jmetalsp.application.biobjectivetsp.sparkutil.StreamingConfigurationTSP;
import org.uma.jmetalsp.problem.DynamicProblem;
import org.uma.jmetalsp.problem.tsp.MultiobjectiveTSPUpdateData;
import org.uma.jmetalsp.streamingdatasource.StreamingDataSource;

import twitter4j.Status;
import twitter4j.auth.Authorization;

/**
 * StreamingTwitterTSP class for get streaming twitter data for TSP problem
 *
 * @author Cristobal Barba <cbarba@lcc.uma.es>
 */
public class StreamingTwitterTSP implements StreamingDataSource<MultiobjectiveTSPUpdateData> {
    private static final int DISTANCE = 0 ;
    private static final int COST = 1 ;
    private Authorization twitterAuth;
    private  String[] filters;
    private DynamicProblem<PermutationSolution<Integer>, MultiobjectiveTSPUpdateData> problem ;
    private StreamingConfigurationTSP streamingConfigurationTSP;
    public StreamingTwitterTSP(StreamingConfigurationTSP streamingConfigurationTSP){
        this.streamingConfigurationTSP=streamingConfigurationTSP;
        this.twitterAuth=streamingConfigurationTSP.getTwitterAuth();
        this.filters = streamingConfigurationTSP.getTwitterFilter().split(",");
    }
  /**
   * Add problem to update
   * @param problem
   */
    @Override
    public void setProblem(DynamicProblem<?, MultiobjectiveTSPUpdateData> problem) {
        this.problem = (DynamicProblem<PermutationSolution<Integer>, MultiobjectiveTSPUpdateData>) problem;
    }
  /**
   * Create a MultiobjectiveTSPUpdateData from data has been generated by Kafka Server and add into a Map
   * For each element in the Map, update the problem
   * @param context
   */
    @Override
    public void start(JavaStreamingContext context) {
        JavaDStream<Status> tweets = TwitterUtils.createStream(context, twitterAuth, filters);
        tweets.foreachRDD(new VoidFunction2<JavaRDD<Status>, Time>() {
            @Override
            public void call(JavaRDD<Status> statusJavaRDD, Time time) throws Exception {
                statusJavaRDD.foreach(new VoidFunction<Status>() {
                    @Override
                    public void call(Status status) throws Exception {
                        int  type = nextInteger(0, 1);
                        int x= nextInteger(0, 93);
                        int y= nextInteger(0, 93);
                        int value=nextInteger(1, 600);
                        MultiobjectiveTSPUpdateData data = new MultiobjectiveTSPUpdateData(type, x, y, value);
                        problem.update(data);
                    }
                });
            }
        });
    }
    private int nextInteger(int min , int max){
        if(min>max){
            int aux = min;
            min=max;
            max=aux;
        }
        int result= min + (int)(Math.random() * ((max - min) + 1));
        return result;
    }
}
